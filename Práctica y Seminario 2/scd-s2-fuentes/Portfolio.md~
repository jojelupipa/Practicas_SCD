---
title: Práctica 2. Monitores.				# Título
author: Jesús Sánchez de Lechina Tejada		# Nombre del autor
header-includes:							# Incluir paquetes en LaTeX
toc: true									# Índice
numbersections: false						# Numeración de secciones
fontsize: 11pt								# Tamaño de fuente
geometry: margin=1in						# Tamaño de los márgenes
---

\newpage

# Productor Consumidor con FIFO

## Variables utilizadas

* int **pos_lectura:** Usada para darle la funcionalidad FIFO a nuestro
  programa, permitiendo el control de acceso sobre nuestro buffer con
  dos variables.
  
* int **n_escrituras:** Al usar números de acceso entre 0 y 9 la condición
  de escritura/lectura es que no estén en la misma posición, esto
  puede pasar en dos ocasiones: Cuando la lectura haya alcanzado a la
  posición de escritura o cuando la escritura haya escrito el máximo
  de elementos posibles en el buffer. Esta variable permite distinguir
  estos dos casos.
  
* bool **DEBUG_MODE:** Booleana que imprime mensajes de depuración en caso
  de estar activada.


## Código Fuente

La principal diferencia radica en que ahora la posición de lectura se
aumenta una vez leída la posición.

```c++
// -----------------------------------------------------------------------------
//
// Sistemas concurrentes y Distribuidos.
// Seminario 2. Introducción a los monitores en C++11.
//
// archivo: prodcons_1.cpp
// Ejemplo de un monitor en C++11 con semántica SC, para el problema
// del productor/consumidor, con un único productor y un único consumidor.
// Opcion FIFO
//
// -----------------------------------------------------------------------------


#include <iostream>
#include <iomanip>
#include <cassert>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <random>

using namespace std ;

bool DEBUG_MODE = false;
constexpr int
num_items  = 40 ;     // número de items a producir/consumir

mutex
mtx ;                 // mutex de escritura en pantalla
unsigned
cont_prod[num_items], // contadores de verificación: producidos
  cont_cons[num_items]; // contadores de verificación: consumidos

//**********************************************************************
// plantilla de función para generar un entero aleatorio uniformemente
// distribuido entre dos valores enteros, ambos incluidos
// (ambos tienen que ser dos constantes, conocidas en tiempo de compilación)
//----------------------------------------------------------------------

template< int min, int max > int aleatorio()
{
  static default_random_engine generador( (random_device())() );
  static uniform_int_distribution<int> distribucion_uniforme( min, max ) ;
  return distribucion_uniforme( generador );
}

//**********************************************************************
// funciones comunes a las dos soluciones (fifo y lifo)
//----------------------------------------------------------------------

int producir_dato()
{
  static int contador = 0 ;
  this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
  mtx.lock();
  cout << "producido: " << contador << endl << flush ;
  mtx.unlock();
  cont_prod[contador] ++ ;
  return contador++ ;
}
//----------------------------------------------------------------------

void consumir_dato( unsigned dato )
{
  if ( num_items <= dato )
    {
      cout << " dato === " << dato << ", num_items == " << num_items << endl ;
      assert( dato < num_items );
    }
  cont_cons[dato] ++ ;
  this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
  mtx.lock();
  cout << "                  consumido: " << dato << endl ;
  mtx.unlock();
}
//----------------------------------------------------------------------

void ini_contadores()
{
  for( unsigned i = 0 ; i < num_items ; i++ )
    {  cont_prod[i] = 0 ;
      cont_cons[i] = 0 ;
    }
}

//----------------------------------------------------------------------

void test_contadores()
{
  bool ok = true ;
  cout << "comprobando contadores ...." << flush ;

  for( unsigned i = 0 ; i < num_items ; i++ )
    {
      if ( cont_prod[i] != 1 )
	{
	  cout << "error: valor " << i << " producido " << cont_prod[i] << " veces." << endl ;
	  ok = false ;
	}
      if ( cont_cons[i] != 1 )
	{
	  cout << "error: valor " << i << " consumido " << cont_cons[i] << " veces" << endl ;
	  ok = false ;
	}
    }
  if (ok)
    cout << endl << flush << "solución (aparentemente) correcta." << endl << flush ;
}

// *****************************************************************************
// clase para monitor buffer, version LIFO, semántica SC, un prod. y un cons.

class ProdCons1SC
{
private:
  static const int           // constantes:
  num_celdas_total = 10;   //  núm. de entradas del buffer
  int                        // variables permanentes
  buffer[num_celdas_total],//  buffer de tamaño fijo, con los datos
    primera_libre ;          //  indice de celda de la próxima inserción
  
  // Variable pos_lectura
  int pos_lectura;
  int n_escrituras;
  
  mutex
  cerrojo_monitor ;        // cerrojo del monitor
  condition_variable         // colas condicion:
  ocupadas,                //  cola donde espera el consumidor (n>0)
    libres ;                 //  cola donde espera el productor  (n<num_celdas_total)

public:                    // constructor y métodos públicos
  ProdCons1SC(  ) ;           // constructor
  int  leer();                // extraer un valor (sentencia L) (consumidor)
  void escribir( int valor ); // insertar un valor (sentencia E) (productor)
} ;
// -----------------------------------------------------------------------------

ProdCons1SC::ProdCons1SC(  )
{
  primera_libre = 0 ;
  pos_lectura = 0;
  n_escrituras = 0;
}
// -----------------------------------------------------------------------------
// función llamada por el consumidor para extraer un dato

int ProdCons1SC::leer(  )
{
  // ganar la exclusión mutua del monitor con una guarda
  unique_lock<mutex> guarda( cerrojo_monitor );

  // esperar bloqueado hasta que 0 < num_celdas_ocupadas
  if(DEBUG_MODE)
    cout << "Intento leer: Primera libre = " << primera_libre << ", pos_lectura = " << pos_lectura << endl;
  if ( primera_libre == pos_lectura )
    ocupadas.wait( guarda );

  if(DEBUG_MODE)
    cout << "Se ha cumplido la condición de espera de la hebra consumidora" << endl;
  // hacer la operación de lectura, actualizando estado del monitor
  assert( primera_libre != pos_lectura  );
  const int valor = buffer[pos_lectura] ;
  pos_lectura = (pos_lectura + 1) % num_celdas_total  ;
  n_escrituras--;

  if(DEBUG_MODE)
    cout << "Se consume buffer[" << pos_lectura << "] = " << buffer[pos_lectura] << endl;


  // señalar al productor que hay un hueco libre, por si está esperando
  libres.notify_one();

  // devolver valor
  return valor ;
}
// -----------------------------------------------------------------------------

void ProdCons1SC::escribir( int valor )
{
  // ganar la exclusión mutua del monitor con una guarda
  unique_lock<mutex> guarda( cerrojo_monitor );

  // esperar bloqueado hasta que num_celdas_ocupadas < num_celdas_total

  if(DEBUG_MODE)
    cout << "Intento escribir el " << valor << ": Primera libre = " << primera_libre << ", pos_lectura = " << pos_lectura << " \nNúmero escrituras: " << n_escrituras << endl;
  if ( primera_libre == num_celdas_total  && n_escrituras == 9)
    libres.wait( guarda );

  //cout << "escribir: ocup == " << num_celdas_ocupadas << ", total == " << num_celdas_total << endl ;
  assert( !(primera_libre == num_celdas_total  && n_escrituras == 9) );

  // hacer la operación de inserción, actualizando estado del monitor
  buffer[primera_libre] = valor ;
  if(DEBUG_MODE)
    cout << "buffer[" << primera_libre << "] = " << buffer[primera_libre] << endl;
  primera_libre = (primera_libre + 1) % num_celdas_total ;
  n_escrituras++;
  
  // señalar al consumidor que ya hay una celda ocupada (por si esta esperando)
  ocupadas.notify_one();
}
// *****************************************************************************
// funciones de hebras

void funcion_hebra_productora( ProdCons1SC * monitor )
{
  for( unsigned i = 0 ; i < num_items ; i++ )
    {
      int valor = producir_dato() ;
      monitor->escribir( valor );
    }
}
// -----------------------------------------------------------------------------

void funcion_hebra_consumidora( ProdCons1SC * monitor )
{
  for( unsigned i = 0 ; i < num_items ; i++ )
    {
      int valor = monitor->leer();
      consumir_dato( valor ) ;
    }
}
// -----------------------------------------------------------------------------

int main()
{
  cout << "-------------------------------------------------------------------------------" << endl
       << "Problema de los productores-consumidores (1 prod/cons, Monitor SC, buffer FIFO). " << endl
       << "-------------------------------------------------------------------------------" << endl
       << flush ;

  ProdCons1SC monitor ;

  thread hebra_productora ( funcion_hebra_productora, &monitor ),
    hebra_consumidora( funcion_hebra_consumidora, &monitor );

  hebra_productora.join() ;
  hebra_consumidora.join() ;

  // comprobar que cada item se ha producido y consumido exactamente una vez
  test_contadores() ;
}
```
# Múltiples productores y consumidores LIFO

## Variables utilizadas

* const int **n_productoras:** Número de hebras productoras,
  simularemos que hay más consumidores que productores.

* const int **n_consumidoras:** Número de hebras consumidoras

* int **id:** Como parámetro para las funciones de las hebras
  productoras y consumidoras le indicamos un ID para que se repartan
  la carga de trabajo. Esto lo conseguimos inicializando el bucle la
  primera iteración sobre el elemento en la posición ID y aumentando
  en función del número de hebras consumidoras/productoras segun
  corresponda.
  
## Código fuente

```c++
// -----------------------------------------------------------------------------
//
// Sistemas concurrentes y Distribuidos.
// Seminario 2. Introducción a los monitores en C++11.
//
// archivo: prodcons_1.cpp
// Ejemplo de un monitor en C++11 con semántica SC, para el problema
// del productor/consumidor, con múltiples productores y consumidores.
// Opcion LIFO (stack)
//
// Historial:
// Creado en Julio de 2017
// -----------------------------------------------------------------------------


#include <iostream>
#include <iomanip>
#include <cassert>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <random>

using namespace std ;

constexpr int
   num_items  = 40 ;     // número de items a producir/consumir

const int n_productoras = 2;
const int n_consumidoras = 4;

mutex
   mtx ;                 // mutex de escritura en pantalla
unsigned
   cont_prod[num_items], // contadores de verificación: producidos
   cont_cons[num_items]; // contadores de verificación: consumidos

//**********************************************************************
// plantilla de función para generar un entero aleatorio uniformemente
// distribuido entre dos valores enteros, ambos incluidos
// (ambos tienen que ser dos constantes, conocidas en tiempo de compilación)
//----------------------------------------------------------------------

template< int min, int max > int aleatorio()
{
  static default_random_engine generador( (random_device())() );
  static uniform_int_distribution<int> distribucion_uniforme( min, max ) ;
  return distribucion_uniforme( generador );
}

//**********************************************************************
// funciones comunes a las dos soluciones (fifo y lifo)
//----------------------------------------------------------------------

int producir_dato()
{
   static int contador = 0 ;
   this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
   mtx.lock();
   cout << "producido: " << contador << endl << flush ;
   mtx.unlock();
   cont_prod[contador] ++ ;
   return contador++ ;
}
//----------------------------------------------------------------------

void consumir_dato( unsigned dato )
{
   if ( num_items <= dato )
   {
      cout << " dato === " << dato << ", num_items == " << num_items << endl ;
      assert( dato < num_items );
   }
   cont_cons[dato] ++ ;
   this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
   mtx.lock();
   cout << "                  consumido: " << dato << endl ;
   mtx.unlock();
}
//----------------------------------------------------------------------

void ini_contadores()
{
   for( unsigned i = 0 ; i < num_items ; i++ )
   {  cont_prod[i] = 0 ;
      cont_cons[i] = 0 ;
   }
}

//----------------------------------------------------------------------

void test_contadores()
{
   bool ok = true ;
   cout << "comprobando contadores ...." << flush ;

   for( unsigned i = 0 ; i < num_items ; i++ )
   {
      if ( cont_prod[i] != 1 )
      {
         cout << "error: valor " << i << " producido " << cont_prod[i] << " veces." << endl ;
         ok = false ;
      }
      if ( cont_cons[i] != 1 )
      {
         cout << "error: valor " << i << " consumido " << cont_cons[i] << " veces" << endl ;
         ok = false ;
      }
   }
   if (ok)
      cout << endl << flush << "solución (aparentemente) correcta." << endl << flush ;
}

// *****************************************************************************
// clase para monitor buffer, version LIFO, semántica SC, un prod. y un cons.

class ProdCons1SC
{
 private:
 static const int           // constantes:
   num_celdas_total = 10;   //  núm. de entradas del buffer
 int                        // variables permanentes
   buffer[num_celdas_total],//  buffer de tamaño fijo, con los datos
   primera_libre ;          //  indice de celda de la próxima inserción
 mutex
   cerrojo_monitor ;        // cerrojo del monitor
 condition_variable         // colas condicion:
   ocupadas,                //  cola donde espera el consumidor (n>0)
   libres ;                 //  cola donde espera el productor  (n<num_celdas_total)

 public:                    // constructor y métodos públicos
   ProdCons1SC(  ) ;           // constructor
   int  leer();                // extraer un valor (sentencia L) (consumidor)
   void escribir( int valor ); // insertar un valor (sentencia E) (productor)
} ;
// -----------------------------------------------------------------------------

ProdCons1SC::ProdCons1SC(  )
{
   primera_libre = 0 ;
}
// -----------------------------------------------------------------------------
// función llamada por el consumidor para extraer un dato

int ProdCons1SC::leer(  )
{
   // ganar la exclusión mutua del monitor con una guarda
   unique_lock<mutex> guarda( cerrojo_monitor );

   // esperar bloqueado hasta que 0 < num_celdas_ocupadas
   if ( primera_libre == 0 )
      ocupadas.wait( guarda );

   // hacer la operación de lectura, actualizando estado del monitor
   assert( 0 < primera_libre  );
   primera_libre-- ;
   const int valor = buffer[primera_libre] ;


   // señalar al productor que hay un hueco libre, por si está esperando
   libres.notify_one();

   // devolver valor
   return valor ;
}
// -----------------------------------------------------------------------------

void ProdCons1SC::escribir( int valor )
{
   // ganar la exclusión mutua del monitor con una guarda
   unique_lock<mutex> guarda( cerrojo_monitor );

   // esperar bloqueado hasta que num_celdas_ocupadas < num_celdas_total
   if ( primera_libre == num_celdas_total )
      libres.wait( guarda );

   //cout << "escribir: ocup == " << num_celdas_ocupadas << ", total == " << num_celdas_total << endl ;
   assert( primera_libre < num_celdas_total );

   // hacer la operación de inserción, actualizando estado del monitor
   buffer[primera_libre] = valor ;
   primera_libre++ ;

   // señalar al consumidor que ya hay una celda ocupada (por si esta esperando)
   ocupadas.notify_one();
}
// *****************************************************************************
// funciones de hebras

void funcion_hebra_productora( ProdCons1SC * monitor, int id )
{
   for( unsigned i = id ; i < num_items ; i+=n_productoras)
   {
      int valor = producir_dato() ;
      //cout << "soy hebra productora " << id << " produzco: " << valor<< endl;
      monitor->escribir( valor );
   }
}
// -----------------------------------------------------------------------------

void funcion_hebra_consumidora( ProdCons1SC * monitor, int id )
{
   for( unsigned i = id ; i < num_items ; i+=n_consumidoras )
   {
      int valor = monitor->leer();
      //cout << "Soy hebra consumidora " << id << " consumo: " << valor<< endl;
      consumir_dato( valor ) ;
   }
}
// -----------------------------------------------------------------------------

int main()
{
   cout << "-------------------------------------------------------------------------------" << endl
        << "Problema de los productores-consumidores (multiples prod/cons, Monitor SC, buffer FIFO). " << endl
        << "-------------------------------------------------------------------------------" << endl
        << flush ;

   ProdCons1SC monitor ;

   thread hebra_productora0 ( funcion_hebra_productora, &monitor,0 ),
     hebra_productora1 ( funcion_hebra_productora, &monitor,1 ),
     hebra_consumidora0( funcion_hebra_consumidora, &monitor,0 ),
     hebra_consumidora1( funcion_hebra_consumidora, &monitor,1 ),
     hebra_consumidora2( funcion_hebra_consumidora, &monitor,2 ),
     hebra_consumidora3( funcion_hebra_consumidora, &monitor,3 );
   

   hebra_productora0.join() ;
   hebra_productora1.join() ;
   
   hebra_consumidora0.join() ;
   hebra_consumidora1.join() ;
   hebra_consumidora2.join() ;
   hebra_consumidora3.join() ;

   // comprobar que cada item se ha producido y consumido exactamente una vez
   test_contadores() ;
}
```


# Múltiples productores y consumidores FIFO

## Variables utilizadas

Partiendo de la previa versión de LIFO para un único
consumidor-productor, con las variables de posición de
escritura/lectura del buffer intermedio y la booleana de depuración,
añadimos las siguientes variables, idénticas al la versión FIFO:

* const int **n_productoras:** Número de hebras productoras, de nuevo,
  habrá menos productores que consumidores (2 y 4).
* const int **n_consumidoras:** Número de hebras consumidoras.

* int **id:** Como parámetro para las funciones de las hebras
  productoras y consumidoras le indicamos un ID para que se repartan
  la carga de trabajo. Esto lo conseguimos inicializando el bucle la
  primera iteración sobre el elemento en la posición ID y aumentando
  en función del número de hebras consumidoras/productoras segun
  corresponda.


## Código fuente

```c++
// -----------------------------------------------------------------------------
//
// Sistemas concurrentes y Distribuidos.
// Seminario 2. Introducción a los monitores en C++11.
//
// archivo: prodcons_1.cpp
// Ejemplo de un monitor en C++11 con semántica SC, para el problema
// del productor/consumidor, con múltiples productores y consumidores.
// Opcion FIFO
//
// -----------------------------------------------------------------------------


#include <iostream>
#include <iomanip>
#include <cassert>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <random>

using namespace std ;

const int n_productoras = 2;
const int n_consumidoras = 4;
bool DEBUG_MODE = false;
constexpr int
num_items  = 40 ;     // número de items a producir/consumir

mutex
mtx ;                 // mutex de escritura en pantalla
unsigned
cont_prod[num_items], // contadores de verificación: producidos
  cont_cons[num_items]; // contadores de verificación: consumidos

//**********************************************************************
// plantilla de función para generar un entero aleatorio uniformemente
// distribuido entre dos valores enteros, ambos incluidos
// (ambos tienen que ser dos constantes, conocidas en tiempo de compilación)
//----------------------------------------------------------------------

template< int min, int max > int aleatorio()
{
  static default_random_engine generador( (random_device())() );
  static uniform_int_distribution<int> distribucion_uniforme( min, max ) ;
  return distribucion_uniforme( generador );
}

//**********************************************************************
// funciones comunes a las dos soluciones (fifo y lifo)
//----------------------------------------------------------------------

int producir_dato()
{
  static int contador = 0 ;
  this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
  mtx.lock();
  cout << "producido: " << contador << endl << flush ;
  mtx.unlock();
  cont_prod[contador] ++ ;
  return contador++ ;
}
//----------------------------------------------------------------------

void consumir_dato( unsigned dato )
{
  if ( num_items <= dato )
    {
      cout << " dato === " << dato << ", num_items == " << num_items << endl ;
      assert( dato < num_items );
    }
  cont_cons[dato] ++ ;
  this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
  mtx.lock();
  cout << "                  consumido: " << dato << endl ;
  mtx.unlock();
}
//----------------------------------------------------------------------

void ini_contadores()
{
  for( unsigned i = 0 ; i < num_items ; i++ )
    {  cont_prod[i] = 0 ;
      cont_cons[i] = 0 ;
    }
}

//----------------------------------------------------------------------

void test_contadores()
{
  bool ok = true ;
  cout << "comprobando contadores ...." << flush ;

  for( unsigned i = 0 ; i < num_items ; i++ )
    {
      if ( cont_prod[i] != 1 )
	{
	  cout << "error: valor " << i << " producido " << cont_prod[i] << " veces." << endl ;
	  ok = false ;
	}
      if ( cont_cons[i] != 1 )
	{
	  cout << "error: valor " << i << " consumido " << cont_cons[i] << " veces" << endl ;
	  ok = false ;
	}
    }
  if (ok)
    cout << endl << flush << "solución (aparentemente) correcta." << endl << flush ;
}

// *****************************************************************************
// clase para monitor buffer, version LIFO, semántica SC, un prod. y un cons.

class ProdCons1SC
{
private:
  static const int           // constantes:
  num_celdas_total = 10;   //  núm. de entradas del buffer
  int                        // variables permanentes
  buffer[num_celdas_total],//  buffer de tamaño fijo, con los datos
    primera_libre ;          //  indice de celda de la próxima inserción
  
  // Variable pos_lectura
  int pos_lectura;
  int n_escrituras;
  
  mutex
  cerrojo_monitor ;        // cerrojo del monitor
  condition_variable         // colas condicion:
  ocupadas,                //  cola donde espera el consumidor (n>0)
    libres ;                 //  cola donde espera el productor  (n<num_celdas_total)

public:                    // constructor y métodos públicos
  ProdCons1SC(  ) ;           // constructor
  int  leer();                // extraer un valor (sentencia L) (consumidor)
  void escribir( int valor ); // insertar un valor (sentencia E) (productor)
} ;
// -----------------------------------------------------------------------------

ProdCons1SC::ProdCons1SC(  )
{
  primera_libre = 0 ;
  pos_lectura = 0;
  n_escrituras = 0;
}
// -----------------------------------------------------------------------------
// función llamada por el consumidor para extraer un dato

int ProdCons1SC::leer(  )
{
  // ganar la exclusión mutua del monitor con una guarda
  unique_lock<mutex> guarda( cerrojo_monitor );

  // esperar bloqueado hasta que 0 < num_celdas_ocupadas
  if(DEBUG_MODE)
    cout << "Intento leer: Primera libre = " << primera_libre << ", pos_lectura = " << pos_lectura << endl;
  if ( primera_libre == pos_lectura )
    ocupadas.wait( guarda );

  if(DEBUG_MODE)
    cout << "Se ha cumplido la condición de espera de la hebra consumidora" << endl;
  // hacer la operación de lectura, actualizando estado del monitor
  assert( primera_libre != pos_lectura  );
  const int valor = buffer[pos_lectura] ;
  pos_lectura = (pos_lectura + 1) % num_celdas_total  ;
  n_escrituras--;

  if(DEBUG_MODE)
    cout << "Se consume buffer[" << pos_lectura << "] = " << buffer[pos_lectura] << endl;


  // señalar al productor que hay un hueco libre, por si está esperando
  libres.notify_one();

  // devolver valor
  return valor ;
}
// -----------------------------------------------------------------------------

void ProdCons1SC::escribir( int valor )
{
  // ganar la exclusión mutua del monitor con una guarda
  unique_lock<mutex> guarda( cerrojo_monitor );

  // esperar bloqueado hasta que num_celdas_ocupadas < num_celdas_total

  if(DEBUG_MODE)
    cout << "Intento escribir el " << valor << ": Primera libre = " << primera_libre << ", pos_lectura = " << pos_lectura << " \nNúmero escrituras: " << n_escrituras << endl;
  if ( primera_libre == num_celdas_total  && n_escrituras == 9)
    libres.wait( guarda );

  //cout << "escribir: ocup == " << num_celdas_ocupadas << ", total == " << num_celdas_total << endl ;
  assert( !(primera_libre == num_celdas_total  && n_escrituras == 9) );

  // hacer la operación de inserción, actualizando estado del monitor
  buffer[primera_libre] = valor ;
  if(DEBUG_MODE)
    cout << "buffer[" << primera_libre << "] = " << buffer[primera_libre] << endl;
  primera_libre = (primera_libre + 1) % num_celdas_total ;
  n_escrituras++;
  
  // señalar al consumidor que ya hay una celda ocupada (por si esta esperando)
  ocupadas.notify_one();
}
// *****************************************************************************
// funciones de hebras

void funcion_hebra_productora( ProdCons1SC * monitor, int id )
{
  for( unsigned i = id ; i < num_items ; i+=n_productoras )
    {
      int valor = producir_dato() ;
      monitor->escribir( valor );
    }
}
// -----------------------------------------------------------------------------

void funcion_hebra_consumidora( ProdCons1SC * monitor, int id )
{
  for( unsigned i = id ; i < num_items ; i+=n_consumidoras )
    {
      int valor = monitor->leer();
      consumir_dato( valor ) ;
    }
}
// -----------------------------------------------------------------------------

int main()
{
  cout << "-------------------------------------------------------------------------------" << endl
       << "Problema de los productores-consumidores (multiples prod/cons, Monitor SC, buffer FIFO). " << endl
       << "-------------------------------------------------------------------------------" << endl
       << flush ;

  ProdCons1SC monitor ;

   thread hebra_productora0 ( funcion_hebra_productora, &monitor,0 ),
     hebra_productora1 ( funcion_hebra_productora, &monitor,1 ),
     hebra_consumidora0( funcion_hebra_consumidora, &monitor,0 ),
     hebra_consumidora1( funcion_hebra_consumidora, &monitor,1 ),
     hebra_consumidora2( funcion_hebra_consumidora, &monitor,2 ),
     hebra_consumidora3( funcion_hebra_consumidora, &monitor,3 );
   

   hebra_productora0.join() ;
   hebra_productora1.join() ;
   
   hebra_consumidora0.join() ;
   hebra_consumidora1.join() ;
   hebra_consumidora2.join() ;
   hebra_consumidora3.join() ;

  // comprobar que cada item se ha producido y consumido exactamente una vez
  test_contadores() ;
}
```
# Múltiples productores y consumidores con semántica SU LIFO

## Variables usadas

En este caso hay que destacar, más que variables utilizadas, los
cambios que se han producido, pues con la definición del nuevo tipo de
monitor con semántica SU ahora todas las variables de tipo ProdCons1SC
que usábamos o que esperábamos como argumento son de la nueva clase
que hemos creado: **ProdCons1SU**.

Eliminamos el cerrojo del monitor.

Las colas las sustituimos por colas del tipo `CondVar`, y en el
constructor las inicializaremos con `newCondVar()`. Esto implica que
ahora los “*wait()*” se llamarán sin guardas, y en lugar de usar
”*notify_one()*” se llamará a “*signal()*” para indicar a la otra cola
que puede liberar a una hebra para realizar su función.

`primera_libre`: Vuelve a ser el índice de nuestra pila (LIFO).

Hemos sustituido el monitor en el main por una referencia a este. Esto
lo conseguimos declarándolo así:

` MRef<ProdCons1SU> monitor = Create<ProdCons1SU>() ;`

Esto implica la necesidad de realizar ciertos cambios. Primero la
hebra habrá que lanzarla pasándole esta variable monitor, en lugar
de lanzarla mediante una referencia (ahora no es necesario pues la
variable monitor ya es una referencia).

Además en las funciones de las hebras habrá que cambiar el tipo de
dato del argumento, que ahora serán del tipo 

`(MRef<ProdCons1SU> monitor, int id) ` 

## Código fuente

```c++
// -----------------------------------------------------------------------------
//
// Sistemas concurrentes y Distribuidos.
// Seminario 2. Introducción a los monitores en C++11.
//
// archivo: prodcons_1.cpp
// Ejemplo de un monitor en C++11 con semántica SC, para el problema
// del productor/consumidor, con múltiples productores y consumidores.
// Opcion LIFO (stack)
//
// Historial:
// Creado en Julio de 2017
// -----------------------------------------------------------------------------


#include <iostream>
#include <iomanip>
#include <cassert>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <random>
#include "HoareMonitor.hpp"
using namespace HM;
using namespace std ;

constexpr int
   num_items  = 40 ;     // número de items a producir/consumir

const int n_productoras = 2;
const int n_consumidoras = 4;

mutex
   mtx ;                 // mutex de escritura en pantalla
unsigned
   cont_prod[num_items], // contadores de verificación: producidos
   cont_cons[num_items]; // contadores de verificación: consumidos

//**********************************************************************
// plantilla de función para generar un entero aleatorio uniformemente
// distribuido entre dos valores enteros, ambos incluidos
// (ambos tienen que ser dos constantes, conocidas en tiempo de compilación)
//----------------------------------------------------------------------

template< int min, int max > int aleatorio()
{
  static default_random_engine generador( (random_device())() );
  static uniform_int_distribution<int> distribucion_uniforme( min, max ) ;
  return distribucion_uniforme( generador );
}

//**********************************************************************
// funciones comunes a las dos soluciones (fifo y lifo)
//----------------------------------------------------------------------

int producir_dato()
{
   static int contador = 0 ;
   this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
   mtx.lock();
   cout << "producido: " << contador << endl << flush ;
   mtx.unlock();
   cont_prod[contador] ++ ;
   return contador++ ;
}
//----------------------------------------------------------------------

void consumir_dato( unsigned dato )
{
   if ( num_items <= dato )
   {
      cout << " dato === " << dato << ", num_items == " << num_items << endl ;
      assert( dato < num_items );
   }
   cont_cons[dato] ++ ;
   this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
   mtx.lock();
   cout << "                  consumido: " << dato << endl ;
   mtx.unlock();
}
//----------------------------------------------------------------------

void ini_contadores()
{
   for( unsigned i = 0 ; i < num_items ; i++ )
   {  cont_prod[i] = 0 ;
      cont_cons[i] = 0 ;
   }
}

//----------------------------------------------------------------------

void test_contadores()
{
   bool ok = true ;
   cout << "comprobando contadores ...." << flush ;

   for( unsigned i = 0 ; i < num_items ; i++ )
   {
      if ( cont_prod[i] != 1 )
      {
         cout << "error: valor " << i << " producido " << cont_prod[i] << " veces." << endl ;
         ok = false ;
      }
      if ( cont_cons[i] != 1 )
      {
         cout << "error: valor " << i << " consumido " << cont_cons[i] << " veces" << endl ;
         ok = false ;
      }
   }
   if (ok)
      cout << endl << flush << "solución (aparentemente) correcta." << endl << flush ;
}

// *****************************************************************************
// clase para monitor buffer, version LIFO, semántica SU, varios prodcons.

class ProdCons1SU:public HoareMonitor
{
 private:
 static const int           // constantes:
   num_celdas_total = 10;   //  núm. de entradas del buffer
 int                        // variables permanentes
   buffer[num_celdas_total],//  buffer de tamaño fijo, con los datos
   primera_libre ;          //  indice de celda de la próxima inserción
  //mutex
  //cerrojo_monitor ;        // cerrojo del monitor
 CondVar         // colas condicion:
   ocupadas,                //  cola donde espera el consumidor (n>0)
   libres ;                 //  cola donde espera el productor  (n<num_celdas_total)

 public:                    // constructor y métodos públicos
   ProdCons1SU(  ) ;           // constructor
   int  leer();                // extraer un valor (sentencia L) (consumidor)
   void escribir( int valor ); // insertar un valor (sentencia E) (productor)
} ;
// -----------------------------------------------------------------------------

ProdCons1SU::ProdCons1SU(  )
{
   primera_libre = 0 ;
   ocupadas = newCondVar();
   libres = newCondVar();
}
// -----------------------------------------------------------------------------
// función llamada por el consumidor para extraer un dato

int ProdCons1SU::leer(  )
{
   
   // esperar bloqueado hasta que 0 < num_celdas_ocupadas
   if ( primera_libre == 0 )
      ocupadas.wait(  );

   // hacer la operación de lectura, actualizando estado del monitor
   assert( 0 < primera_libre  );
   primera_libre-- ;
   const int valor = buffer[primera_libre] ;


   // señalar al productor que hay un hueco libre, por si está esperando
   libres.signal();

   // devolver valor
   return valor ;
}
// -----------------------------------------------------------------------------

void ProdCons1SU::escribir( int valor )
{
   // esperar bloqueado hasta que num_celdas_ocupadas < num_celdas_total
   if ( primera_libre == num_celdas_total )
      libres.wait(  );

   //cout << "escribir: ocup == " << num_celdas_ocupadas << ", total == " << num_celdas_total << endl ;
   assert( primera_libre < num_celdas_total );

   // hacer la operación de inserción, actualizando estado del monitor
   buffer[primera_libre] = valor ;
   primera_libre++ ;

   // señalar al consumidor que ya hay una celda ocupada (por si esta esperando)
   ocupadas.signal();
}
// *****************************************************************************
// funciones de hebras

void funcion_hebra_productora( MRef<ProdCons1SU> monitor, int id )
{
   for( unsigned i = id ; i < num_items ; i+=n_productoras)
   {
      int valor = producir_dato() ;
      //cout << "soy hebra productora " << id << " produzco: " << valor<< endl;
      monitor->escribir( valor );
   }
}
// -----------------------------------------------------------------------------

void funcion_hebra_consumidora( MRef<ProdCons1SU> monitor, int id )
{
   for( unsigned i = id ; i < num_items ; i+=n_consumidoras )
   {
      int valor = monitor->leer();
      //cout << "Soy hebra consumidora " << id << " consumo: " << valor<< endl;
      consumir_dato( valor ) ;
   }
}
// -----------------------------------------------------------------------------

int main()
{
   cout << "-------------------------------------------------------------------------------" << endl
        << "Problema de los productores-consumidores (multiples prod/cons, Monitor SU, buffer LIFO). " << endl
        << "-------------------------------------------------------------------------------" << endl
        << flush ;

   MRef<ProdCons1SU> monitor = Create<ProdCons1SU>() ;

   thread hebra_productora0 ( funcion_hebra_productora, monitor,0 ),
     hebra_productora1 ( funcion_hebra_productora, monitor,1 ),
     hebra_consumidora0( funcion_hebra_consumidora, monitor,0 ),
     hebra_consumidora1( funcion_hebra_consumidora, monitor,1 ),
     hebra_consumidora2( funcion_hebra_consumidora, monitor,2 ),
     hebra_consumidora3( funcion_hebra_consumidora, monitor,3 );
   

   hebra_productora0.join() ;
   hebra_productora1.join() ;
   
   hebra_consumidora0.join() ;
   hebra_consumidora1.join() ;
   hebra_consumidora2.join() ;
   hebra_consumidora3.join() ;

   // comprobar que cada item se ha producido y consumido exactamente una vez
   test_contadores() ;
}

```


# Múltiples productores y consumidores con semántica SU FIFO

## Variables usadas

Para este ejercicio hemos partido del apartado anterior, múltiples
productores/consumidores con semántica SU LIFO. 

El primer cambio que hemos hecho se aprecia en la función main. Se ha
sustituido la inicialización individual de cada hebra por una
inicialización en un array para así dar cabida a problemas de escalado
sin tener que modificar más que el valor de las variables que indican
el número de hebras productoras y consumidoras.

Posteriormente hemos modificado el funcionamiento para adaptar el uso
del buffer a una cola (FIFO).

Hemos añadido dos variables booleanas para comprobar si el buffer está
lleno o si tiene todas sus posiciones libres:

```c++
bool todas_ocupadas;
bool todas_libres;
```

En un primer momento todas libres se incializará a `true` y todas
ocupadas a `false`. La utilidad de estas variables es poder discernir
entre el caso en el que la posición de lectura alcance a la de
escritura del caso contrario.

## Código fuente

```c++
// -----------------------------------------------------------------------------
//
// Sistemas concurrentes y Distribuidos.
// Seminario 2. Introducción a los monitores en C++11.
//
// archivo: prodcons_1.cpp
// Ejemplo de un monitor en C++11 con semántica SC, para el problema
// del productor/consumidor, con múltiples productores y consumidores.
// Opcion LIFO (stack)
//
// Historial:
// Creado en Julio de 2017
// -----------------------------------------------------------------------------


#include <iostream>
#include <iomanip>
#include <cassert>
#include <thread>
#include <mutex>
#include <condition_variable>
#include <random>
#include "HoareMonitor.hpp"
using namespace HM;
using namespace std ;

constexpr int
   num_items  = 40 ;     // número de items a producir/consumir

const int n_productoras = 2;
const int n_consumidoras = 4;

mutex
   mtx ;                 // mutex de escritura en pantalla
unsigned
   cont_prod[num_items], // contadores de verificación: producidos
   cont_cons[num_items]; // contadores de verificación: consumidos

//**********************************************************************
// plantilla de función para generar un entero aleatorio uniformemente
// distribuido entre dos valores enteros, ambos incluidos
// (ambos tienen que ser dos constantes, conocidas en tiempo de compilación)
//----------------------------------------------------------------------

template< int min, int max > int aleatorio()
{
  static default_random_engine generador( (random_device())() );
  static uniform_int_distribution<int> distribucion_uniforme( min, max ) ;
  return distribucion_uniforme( generador );
}

//**********************************************************************
// funciones comunes a las dos soluciones (fifo y lifo)
//----------------------------------------------------------------------

int producir_dato()
{
   static int contador = 0 ;
   this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
   mtx.lock();
   cout << "producido: " << contador << endl << flush ;
   mtx.unlock();
   cont_prod[contador] ++ ;
   return contador++ ;
}
//----------------------------------------------------------------------

void consumir_dato( unsigned dato )
{
   if ( num_items <= dato )
   {
      cout << " dato === " << dato << ", num_items == " << num_items << endl ;
      assert( dato < num_items );
   }
   cont_cons[dato] ++ ;
   this_thread::sleep_for( chrono::milliseconds( aleatorio<20,100>() ));
   mtx.lock();
   cout << "                  consumido: " << dato << endl ;
   mtx.unlock();
}
//----------------------------------------------------------------------

void ini_contadores()
{
   for( unsigned i = 0 ; i < num_items ; i++ )
   {  cont_prod[i] = 0 ;
      cont_cons[i] = 0 ;
   }
}

//----------------------------------------------------------------------

void test_contadores()
{
   bool ok = true ;
   cout << "comprobando contadores ...." << flush ;

   for( unsigned i = 0 ; i < num_items ; i++ )
   {
      if ( cont_prod[i] != 1 )
      {
         cout << "error: valor " << i << " producido " << cont_prod[i] << " veces." << endl ;
         ok = false ;
      }
      if ( cont_cons[i] != 1 )
      {
         cout << "error: valor " << i << " consumido " << cont_cons[i] << " veces" << endl ;
         ok = false ;
      }
   }
   if (ok)
      cout << endl << flush << "solución (aparentemente) correcta." << endl << flush ;
}

// *****************************************************************************
// clase para monitor buffer, version FIFO, semántica SU, varios prodcons.

class ProdCons1SU:public HoareMonitor
{
 private:
 static const int           // constantes:
   num_celdas_total = 10;   //  núm. de entradas del buffer
 int                        // variables permanentes
   buffer[num_celdas_total],//  buffer de tamaño fijo, con los datos
   primera_libre ;          //  indice de celda de la próxima inserción

  int primera_ocupada;
  bool todas_ocupadas, todas_libres;
  //mutex
  //cerrojo_monitor ;        // cerrojo del monitor
 CondVar         // colas condicion:
   ocupadas,                //  cola donde espera el consumidor (n>0)
   libres ;                 //  cola donde espera el productor  (n<num_celdas_total)

 public:                    // constructor y métodos públicos
   ProdCons1SU(  ) ;           // constructor
   int  leer();                // extraer un valor (sentencia L) (consumidor)
   void escribir( int valor ); // insertar un valor (sentencia E) (productor)
} ;
// -----------------------------------------------------------------------------

ProdCons1SU::ProdCons1SU(  )
{
  todas_ocupadas = false;
  todas_libres = true;
   primera_libre = 0 ;
   primera_ocupada = 0;
   ocupadas = newCondVar();
   libres = newCondVar();
}
// -----------------------------------------------------------------------------
// función llamada por el consumidor para extraer un dato

int ProdCons1SU::leer(  )
{
   
   // esperar bloqueado hasta que 0 < num_celdas_ocupadas
   if ( todas_libres )
      ocupadas.wait(  );

   // hacer la operación de lectura, actualizando estado del monitor
   const int valor = buffer[primera_ocupada] ;
   primera_ocupada = (primera_ocupada + 1) % num_celdas_total  ;
   if(primera_ocupada == primera_libre)
     todas_libres = true;
   todas_ocupadas = false;


   // señalar al productor que hay un hueco libre, por si está esperando
   libres.signal();

   // devolver valor
   return valor ;
}
// -----------------------------------------------------------------------------

void ProdCons1SU::escribir( int valor )
{
   // esperar bloqueado hasta que num_celdas_ocupadas < num_celdas_total
   if ( todas_ocupadas)
      libres.wait(  );

   //cout << "escribir: ocup == " << num_celdas_ocupadas << ", total == " << num_celdas_total << endl ;

   // hacer la operación de inserción, actualizando estado del monitor
   buffer[primera_libre] = valor ;
  primera_libre = (primera_libre + 1) % num_celdas_total ;
  if(primera_ocupada == primera_libre)
    todas_ocupadas = true;
  todas_libres = false;


   // señalar al consumidor que ya hay una celda ocupada (por si esta esperando)
   ocupadas.signal();
}
// *****************************************************************************
// funciones de hebras

void funcion_hebra_productora( MRef<ProdCons1SU> monitor, int id )
{
   for( unsigned i = id ; i < num_items ; i+=n_productoras)
   {
      int valor = producir_dato() ;
      //cout << "soy hebra productora " << id << " produzco: " << valor<< endl;
      monitor->escribir( valor );
   }
}
// -----------------------------------------------------------------------------

void funcion_hebra_consumidora( MRef<ProdCons1SU> monitor, int id )
{
   for( unsigned i = id ; i < num_items ; i+=n_consumidoras )
   {
      int valor = monitor->leer();
      //cout << "Soy hebra consumidora " << id << " consumo: " << valor<< endl;
      consumir_dato( valor ) ;
   }
}
// -----------------------------------------------------------------------------

int main()
{
   cout << "-------------------------------------------------------------------------------" << endl
        << "Problema de los productores-consumidores (multiples prod/cons, Monitor SU, buffer LIFO). " << endl
        << "-------------------------------------------------------------------------------" << endl
        << flush ;

   MRef<ProdCons1SU> monitor = Create<ProdCons1SU>() ;

   thread hebras_prod[n_productoras];
   thread hebras_cons[n_consumidoras];

   for(int i = 0; i < n_productoras;i++)
     hebras_prod[i] = thread (funcion_hebra_productora, monitor, i);

   for(int i = 0; i < n_consumidoras;i++)
     hebras_cons[i] = thread (funcion_hebra_consumidora,monitor,i);
   

   for(int i = 0; i < n_productoras;i++)
     hebras_prod[i].join();

   for(int i = 0; i < n_consumidoras;i++)
     hebras_cons[i].join();
       
   // comprobar que cada item se ha producido y consumido exactamente una vez
   test_contadores() ;
}
```
